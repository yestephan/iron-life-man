---
phase: 01-oauth-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/google/oauth-client.ts
  - app/api/auth/google/authorize/route.ts
  - app/api/auth/google/callback/route.ts
  - app/actions/calendar/tokens.ts
autonomous: true

must_haves:
  truths:
    - "Visiting /api/auth/google/authorize redirects authenticated user to Google OAuth consent screen with calendar scopes"
    - "Google OAuth callback exchanges code for tokens and stores them encrypted in Supabase Vault"
    - "OAuth state parameter is validated to prevent CSRF attacks"
    - "OAuth denial or cancel is treated as skip and redirects gracefully"
    - "Tokens can be retrieved from Vault and used to create authenticated OAuth2Client"
    - "OAuth2Client automatically refreshes expired tokens and persists new tokens to Vault"
  artifacts:
    - path: "lib/google/oauth-client.ts"
      provides: "OAuth2Client factory with automatic token refresh"
      exports: ["createOAuth2ClientInstance", "generateAuthorizationUrl", "createAuthenticatedClient"]
    - path: "app/api/auth/google/authorize/route.ts"
      provides: "OAuth initiation endpoint"
      exports: ["GET"]
    - path: "app/api/auth/google/callback/route.ts"
      provides: "OAuth callback handler"
      exports: ["GET"]
    - path: "app/actions/calendar/tokens.ts"
      provides: "Server Actions for Vault-encrypted token CRUD"
      exports: ["storeGoogleTokens", "getGoogleTokens", "updateGoogleTokens", "deleteGoogleTokens"]
  key_links:
    - from: "app/api/auth/google/authorize/route.ts"
      to: "lib/google/oauth-client.ts"
      via: "imports createOAuth2ClientInstance and generateAuthorizationUrl"
      pattern: "import.*oauth-client"
    - from: "app/api/auth/google/callback/route.ts"
      to: "app/actions/calendar/tokens.ts"
      via: "calls storeGoogleTokens after code exchange"
      pattern: "storeGoogleTokens"
    - from: "lib/google/oauth-client.ts"
      to: "app/actions/calendar/tokens.ts"
      via: "createAuthenticatedClient calls getGoogleTokens and listens for refresh"
      pattern: "getGoogleTokens|updateGoogleTokens"
    - from: "app/actions/calendar/tokens.ts"
      to: "Supabase Vault"
      via: "RPC calls to vault_create_secret, vault_read_secret, vault_update_secret"
      pattern: "vault_create_secret|vault_read_secret"
---

<objective>
Implement the complete Google OAuth 2.0 flow with Vault-encrypted token storage and automatic token refresh.

Purpose: This is the core authentication pipeline for GCAL-01 (OAuth authorization), GCAL-10 (automatic token refresh), and DATA-03 (encrypted token storage). Users need to authorize Google Calendar access, and the system needs to securely store and automatically refresh tokens without user intervention.

Output: OAuth Route Handlers (authorize + callback), Server Actions for Vault token management, OAuth2Client factory with auto-refresh.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-oauth-foundation/01-CONTEXT.md
@.planning/phases/01-oauth-foundation/01-RESEARCH.md
@.planning/phases/01-oauth-foundation/01-01-SUMMARY.md

@lib/supabase/server.ts
@lib/supabase/auth.ts
@types/database.ts
@supabase/migrations/005_vault_setup.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Server Actions for Vault-encrypted token management</name>
  <files>app/actions/calendar/tokens.ts</files>
  <action>
    Create `app/actions/calendar/tokens.ts` as a Server Action file ('use server' directive).

    Import `createClient` from `@/lib/supabase/server` (NOT the admin client - use the authenticated client that respects RLS).

    Implement these exported functions:

    **storeGoogleTokens(userId: string, accessToken: string, refreshToken: string | null | undefined, expiresAt: string): Promise<void>**
    1. Create Supabase client via createClient()
    2. Call `supabase.rpc('vault_create_secret', { secret: accessToken, name: 'google_access_' + userId, description: 'Google Calendar access token' })` to encrypt and store access token. Capture returned UUID.
    3. If refreshToken is provided, call `supabase.rpc('vault_create_secret', ...)` for refresh token too. Capture UUID.
    4. Upsert into `integrations` table with: user_id, provider='google_calendar', access_token=accessVaultUUID (the UUID string, NOT the token), refresh_token=refreshVaultUUID, token_expires_at=expiresAt, is_active=true, last_sync_status='connected'.
    5. Use onConflict: 'user_id,provider' for upsert.
    6. Handle errors: if vault call fails, throw with descriptive message. If upsert fails, clean up vault secrets.

    **getGoogleTokens(userId: string): Promise<{ access_token: string; refresh_token: string | null; expiry_date: number } | null>**
    1. Get integration record from `integrations` table where user_id=userId, provider='google_calendar', is_active=true.
    2. If no record, return null.
    3. Call `supabase.rpc('vault_read_secret', { secret_id: integration.access_token })` to decrypt access token.
    4. If integration.refresh_token exists, decrypt it too.
    5. Return object with decrypted access_token, decrypted refresh_token, and expiry_date as epoch milliseconds from token_expires_at.
    6. If decryption fails (vault secret missing), return null and log warning.

    **updateGoogleTokens(userId: string, tokens: { access_token?: string; refresh_token?: string | null; expiry_date?: string }): Promise<void>**
    1. Get integration record to find existing Vault secret UUIDs.
    2. If tokens.access_token provided: call `supabase.rpc('vault_update_secret', { secret_id: existingAccessVaultId, new_secret: tokens.access_token })`.
    3. If tokens.refresh_token provided: call `supabase.rpc('vault_update_secret', ...)` for refresh token.
    4. Update integration record's token_expires_at if expiry_date provided.
    5. Update updated_at timestamp.

    **deleteGoogleTokens(userId: string): Promise<void>**
    1. Get integration record.
    2. Delete Vault secrets for both access and refresh tokens via vault_delete_secret RPC.
    3. Update integration record: set is_active=false, access_token=null, refresh_token=null, last_sync_status='disconnected'.

    IMPORTANT: Use the supabaseAdmin client (from server.ts) for Vault RPC calls since Vault functions need service role access. Use regular authenticated client for integrations table queries (respects RLS).
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify types are correct. Verify the file uses 'use server' directive. Check all 4 functions are exported.
  </verify>
  <done>
    Server Actions file exists with storeGoogleTokens, getGoogleTokens, updateGoogleTokens, deleteGoogleTokens. All functions use Vault RPC for encryption. No plaintext tokens stored in integrations table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OAuth Route Handlers and OAuth2Client factory</name>
  <files>lib/google/oauth-client.ts, app/api/auth/google/authorize/route.ts, app/api/auth/google/callback/route.ts</files>
  <action>
    **Create `lib/google/oauth-client.ts`:**

    1. Export `createOAuth2ClientInstance()`: Creates a new google.auth.OAuth2 instance with GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, and redirect URI `${NEXT_PUBLIC_APP_URL}/api/auth/google/callback`. No credentials set yet.

    2. Export `generateAuthorizationUrl(oauth2Client: OAuth2Client, state: string): string`: Calls oauth2Client.generateAuthUrl() with:
       - access_type: 'offline' (CRITICAL for refresh token)
       - scope: ['https://www.googleapis.com/auth/calendar', 'https://www.googleapis.com/auth/calendar.calendarlist']
       - state: state parameter for CSRF
       - prompt: 'consent' (force consent to ensure refresh_token per research pitfall #1)
       - include_granted_scopes: true

    3. Export `async createAuthenticatedClient(userId: string)`: Creates OAuth2Client with user's tokens:
       - Call getGoogleTokens(userId) to retrieve decrypted tokens from Vault
       - If no tokens, throw Error('No Google OAuth tokens found for user')
       - Create OAuth2Client instance, call setCredentials() with tokens
       - Attach 'tokens' event listener that calls updateGoogleTokens() when tokens are refreshed automatically by the library
       - Return the authenticated client

    Import { google } from 'googleapis'. Import token functions from '@/app/actions/calendar/tokens'.

    **Create `app/api/auth/google/authorize/route.ts`:**

    Export async GET handler:
    1. Import createClient from @/lib/supabase/server, verify user is authenticated. If not, redirect to /signin.
    2. Generate CSRF state with crypto.randomUUID()
    3. Set state in httpOnly cookie: `oauth_state`, maxAge=600 (10 min), secure in production, sameSite='lax'
    4. Call createOAuth2ClientInstance() and generateAuthorizationUrl() with state
    5. Return NextResponse.redirect(authUrl)
    6. Add `export const dynamic = 'force-dynamic';` to prevent caching of this route

    **Create `app/api/auth/google/callback/route.ts`:**

    Export async GET handler:
    1. Extract `code`, `state`, `error` from searchParams
    2. If error === 'access_denied': delete oauth_state cookie, redirect to `/onboarding/calendar-connect?skipped=true` (per user decision: treat denial same as skip)
    3. Validate state against stored cookie value. If mismatch, redirect to `/onboarding/calendar-connect?error=invalid_state`
    4. If no code, redirect with error=missing_code
    5. Verify user is authenticated via Supabase. If not, redirect to /signin.
    6. Exchange code for tokens: `const { tokens } = await oauth2Client.getToken(code)`
    7. Call storeGoogleTokens(user.id, tokens.access_token!, tokens.refresh_token, new Date(tokens.expiry_date!).toISOString())
    8. Delete oauth_state cookie
    9. Redirect to `/onboarding/calendar-connect?step=select` to continue to calendar selection
    10. Wrap in try/catch: on error, redirect to `/onboarding/calendar-connect?error=token_exchange`
    11. Add `export const dynamic = 'force-dynamic';`

    IMPORTANT per user decisions:
    - OAuth denial/cancel = same as skip (redirect gracefully, no error message)
    - After approval, continue to calendar selection step
    - Callback also needs to handle the case where user is connecting from settings (not just onboarding). Use a `redirect` query parameter in the authorize route to know where to redirect after callback. Default to onboarding flow.
  </action>
  <verify>
    Run `npx tsc --noEmit`. Verify:
    - authorize route generates valid OAuth URL with offline access and consent prompt
    - callback route validates state, exchanges code, stores tokens in Vault
    - OAuth2Client factory creates authenticated clients with auto-refresh
    - No plaintext tokens are exposed to client
  </verify>
  <done>
    Three files created. OAuth authorize redirects to Google with proper scopes and CSRF state. Callback exchanges code, stores encrypted tokens, and redirects to calendar selection. OAuth2Client factory creates authenticated clients that auto-refresh and persist new tokens.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `/api/auth/google/authorize` route exists and exports GET
3. `/api/auth/google/callback` route exists and exports GET
4. Token Server Actions use Vault RPC (not direct table inserts)
5. State parameter validation is present in callback
6. access_type='offline' and prompt='consent' are set in auth URL
7. OAuth2Client 'tokens' event listener persists refreshed tokens
</verification>

<success_criteria>
- GCAL-01: OAuth flow endpoints exist to authorize Google Calendar access
- GCAL-10: OAuth2Client factory with automatic token refresh that persists to Vault
- DATA-03: All tokens encrypted via Vault RPC, only UUIDs stored in integrations table
- Security: CSRF state validation, httpOnly cookies, server-side only token handling
</success_criteria>

<output>
After completion, create `.planning/phases/01-oauth-foundation/01-02-SUMMARY.md`
</output>
